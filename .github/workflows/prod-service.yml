name: Deploy Layer8 Server to Production Environment

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build-layer8:
    name: Build Layer8 Server
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: kciter/aws-ecr-action@v3
        with:
          access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          repo: layer8
          region: ${{ vars.AWS_REGION }}
          tags: latest,${{ github.sha }}
          create_repo: true
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"

      - name: Install Database Migration CLI
        run: |
          go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest

      - name: Run Database Migration
        run: |
          migrate -path migrations -database "${{ secrets.PRODUCTION_POSTGRESQL_URL }}" up
  deploy-layer8-server-production:
    name: "Deploy Layer 8 to Production"
    environment: "production"
    needs: [build-layer8]
    runs-on: ubuntu-latest
    env:
      ECS_CLUSTER: "layer8-production"
      ECS_SERVICE: "layer8-server"
    defaults:
      run:
        working-directory: infra/production/layer8
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      # - name: Install AWS CLI
      #   run: |
      #     curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
      #     unzip awscliv2.zip
      #     sudo ./aws/install

      - name: Populate Application Environment Variables to S3
        id: populateappenv
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ vars.AWS_REGION }}
        run: |
          echo -e "${{ vars.PRODUCTION_APP_ENV }}" >> app.env
          /usr/local/aws-cli/v2/current/bin/aws s3 cp ./app.env s3://${{ vars.PRODUCTION_S3_APP_ENV_LOCATION }}
      
      - name: Add Terraform Environment Variables
        id: addtfenv
        run: |
          echo -e "$TFVARS_STRING" >> terraform.tfvars
        env:
          TFVARS_STRING: |
            ecr_image_tag = "${{ github.sha }}"
            s3_arn_env_file = "arn:aws:s3:::${{ vars.PRODUCTION_S3_APP_ENV_LOCATION }}"
            ecr_repository_url = "${{ vars.ECR_REPOSITORY_URL }}"
            influxdb_url = "${{ vars.PRODUCTION_INFLUXDB_URL }}"
            influxdb_token = "${{ secrets.PRODUCTION_INFLUXDB_TOKEN }}"
            cloudflare_tunnel_token = "${{ secrets.PRODUCTION_LAYER8_CLOUDFLARE_TUNNEL_TOKEN }}"
      
      - name: Terraform Init
        id: init
        run: terraform init

      - name: Terraform Plan
        id: plan
        run: terraform plan

      - name: Terraform Apply
        id: apply
        run: terraform apply

      - name: Wait for service stability
        run: |
          echo "Waiting for ECS service to stabilize..."

          sleep 60
        
          MAX_ATTEMPTS=30
          WAIT_SECONDS=20
          attempt=1
        
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].deployments[0].status' \
              --output text)
            
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].runningCount' \
              --output text)
            
            DESIRED_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].desiredCount' \
              --output text)
          
            echo "Attempt $attempt of $MAX_ATTEMPTS"
            echo "Deployment Status: $DEPLOYMENT_STATUS"
            echo "Running Count: $RUNNING_COUNT of $DESIRED_COUNT"
          
            if [ "$DEPLOYMENT_STATUS" = "PRIMARY" ] && [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ]; then
            # Additional check for task health
              UNHEALTHY_COUNT=$(aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --query 'services[0].deployments[0].failedTasks' \
                --output text)
              
              if [ "$UNHEALTHY_COUNT" = "0" ]; then
                echo "Deployment completed successfully!"
                exit 0
              fi
            fi
          
            if [ "$DEPLOYMENT_STATUS" = "FAILED" ]; then
              echo "Deployment failed!"
              exit 1
            fi
          
            echo "Waiting $WAIT_SECONDS seconds before next check..."
            sleep $WAIT_SECONDS
          
            attempt=$((attempt + 1))
          done
        
          echo "Deployment did not stabilize within the timeout period"
          exit 1
          
      - name: Verify container health
        run: |
          TASK_ARN=$(aws ecs list-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service-name ${{ env.ECS_SERVICE }} \
          --query 'taskArns[0]' \
          --output text)

          CONTAINER_STATUS=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query "tasks[0].containers[?name=='${{ env.CONTAINER_NAME }}'].lastStatus" \
          --output text)

          if [ "$CONTAINER_STATUS" != "RUNNING" ]; then
            echo "Container is not running. Status: $CONTAINER_STATUS"
            exit 1
          fi
